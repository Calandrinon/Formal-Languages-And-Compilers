Lecture 1: generic information about compilers and scanning


Lecture 2: 
	- scanning
	- symbol table (for storing identifiers and constants)
	- visibility domain (scope) -> represented with an inclusion tree, each scope being a separate symbol table
	- formal grammar: (non-terminals, terminals, productions, starting symbol)
	- types of derivations: direct, k, +, *
	- language generated by a grammar: L(G) = {w belongs to terminals* | starting symbol ->(star derivation) w} 
	- Chomsky hierarchy


Lecture 3:
	- finite automata: (Q (states), sigma (alphabet), transition function, initial state, final states)
	- deterministic if |delta(q, a)| <= 1, non-deterministic if |delta(q, a)| > 1
	- configurations: normal move, k move, + move, * move
	- 2 finite automata are equivalent if they accept the same language
	- regular languages
	- right linear grammar if A -> aB or A -> b
	- regular grammar if right linear and A -> epsilon does not belong to P (exception: S -> epsilon, S doesn't appear in the RHS of any production)
	- for any regular grammar there exists a finite automaton such that L(G) = L(M)
	- for any finite automaton M there exists a right linear grammar G such that L(G) = L(M)
	- regular sets
	- regular expressions: priority of operations *, concatenation, +
	- algebraic properties of regex
	- regex equations


Lecture 4:
	- regular sets are right linear languages
	- a language L is a regular set <=> L is a right-linear language
	- a language L is a regular set <=> L is accepted by a FA


Lecture 5:
	- pumping lemma: if L is a regular language, then there is a number p where if w is any sequence in L that is at least of length p, then w may be divided into 3 pieces, w = xyz, satisfying the fofllowing conditions:
		1. for each i >= 0, xy(^i)z belongs to L
		2. |y| > 0
		3. |xy| <= p
	- context-free grammars: A -> alpha
	- the sequence w belongs to the language L generated by G <=> there exists a syntax tree with frontier w
	- a context-free grammar is ambiguous if for a sequence w from L(G) there exist 2 distinct syntax trees with frontier w
	- unproductive symbols, inaccessible symbols, epsilon-productions, single productions	
	- parsing


Lecture 6:
	- types of parsing: descendent recursive, LL(1), LR(k), LR(0), SLR, LR(1), LALR
	- parse tree representations
	- descendent recursive parser steps -> the algorithm never stops if the grammar is left recursive
	- LL(1) parser, first, follow 
	- FIRST(k) - first k terminal symbols that can be generated from alpha (a terminal or a non-terminal)
	- FOLLOW(k) - next k symbols generated after beta


Lecture 7:
	- LL(k):
		-> first L - sequence is read from left to right 	
		-> second L - uses leftmost derivations	
		-> prediction of length k
	- A grammar is LL(k) if for any pair of distinct productions of a nonterminal (A -> beta, A -> gamma, beta != gamma), the condition holds:
		FIRSTk(beta alpha) intersection FIRSTk(gamma alpha) = phi (empty set), 
								  *
		for any alpha such that S => u A alpha 
	- steps for the LL(1) parser:
		1.) construct FIRST and FOLLOW
		2.) construct LL(1) parse table
		3.) analyse sequence based on moves between configurations
	- LL(1) table: 1 line for each symbol belonging to {non-terminal, terminal, '$'}, 1 column for each symbol belonging to {terminal, '$'}
	- table rules: 
		1.) M(A, a) = (alpha, i), for any a belonging to FIRST(alpha), a != epsilon, A -> alpha production number i in P            
			M(A, b) = (alpha, i), if epsilon belongs to FIRST(alpha), for any b belonging to FOLLOW(A), A -> alpha production number i in P
		2.) M(a, a) = pop, for any terminal a
		3.) M($, $) = acc
		4.) M(x, a) = err
	- a grammar is LL(1) if the table contains at most one value in each cell of the table i.e there are no conflicts
	- LL(1) provides the location of the error and grammars can be transformed to be LL(1)

		




